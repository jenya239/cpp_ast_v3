#pragma once

#include <cstdint>
#include <array>
#include <optional>
#include <string>
#include <vector>

default;
    constexpr Vec2(float x_, float y_) : x(x_), y(y_) {}

    operator+(const Vec2& other) const { return {x + other.x, y + other.y}; }
    operator-(const Vec2& other) const { return {x - other.x, y - other.y}; }
    operator*(float s) const { return {x * s, y * s}; }
    Vec2& operator +=(const Vec2& other) { x += other.x; y += other.y; return *this; }
};

// Прямоугольник (позиция + размер)
default;
    constexpr Rect(float x_, float y_, float w_, float h_)
        : x(x_), y(y_), width(w_), height(h_) {}

    bool contains(float px, float py) const {
        return px >= x && px < x + width && py >= y && py < y + height;
    }

    float area() const { return width * height; }
};

// Цвет RGBA
default;
    constexpr Color(float r_, float g_, float b_, float a_ = 1.0f)
        : r(r_), g(g_), b(b_), a(a_) {}

    static constexpr Color white() { return {1.0f, 1.0f, 1.0f, 1.0f}; }
    static constexpr Color black() { return {0.0f, 0.0f, 0.0f, 1.0f}; }
    static constexpr Color red()   { return {1.0f, 0.0f, 0.0f, 1.0f}; }
    static constexpr Color green() { return {0.0f, 1.0f, 0.0f, 1.0f}; }
    static constexpr Color blue()  { return {0.0f, 0.0f, 1.0f, 1.0f}; }
};

// Метрики глифа (в пикселях)
struct GlyphMetrics {
    Vec2 size;          // Размер растра глифа
    Vec2 bearing;       // Смещение от pen position (bearing_x, bearing_y)
    Vec2 advance;       // Сдвиг pen после отрисовки глифа

    // FreeType даёт:
    // - bearing.x: горизонтальный offset от pen до левого края
    // - bearing.y: вертикальный offset от baseline до верхнего края
    // - advance.x: сдвиг pen по X для следующего глифа
};

// Формат текстурного атласа
enum class AtlasFormat : uint8_t {
    A8,      // 8-bit alpha (FreeType antialiased)
    RGB8,    // 8-bit RGB (для MSDF)
    RGBA8    // 8-bit RGBA (для colored glyphs/emoji)
};

// Режим рендеринга текста
enum class RenderMode : uint8_t {
    BITMAP,  // Обычный bitmap (для мелкого текста <16px)
    MSDF,    // Multi-channel SDF (для крупного масштабируемого текста)
    SDF      // Single-channel SDF (альтернатива MSDF)
};

// Слот в текстурном атласе
struct AtlasSlot {
    AtlasPageID page_id {0};       // ID страницы атласа
    TextureID texture_id {0};      // OpenGL texture ID (важно!)
    Rect pixel_rect;              // Координаты в пикселях на атласе
    Rect uv_rect;                 // Нормализованные UV координаты [0..1]

    bool is_valid() const { return texture_id != 0; }
};

// Ключ для кеша глифов
namespace std {
    template<>
    struct hash<gtkgl::text::GlyphCacheKey> {
        size_t operator()(const gtkgl::text::GlyphCacheKey& k) const noexcept {
            size_t h1 = std::hash<uint32_t>{}(k.font_id);
            size_t h2 = std::hash<uint32_t>{}(k.glyph_index);
            size_t h3 = std::hash<uint16_t>{}(k.size_px);
            size_t h4 = std::hash<uint8_t>{}(static_cast<uint8_t>(k.mode));
            return h1 ^ (h2 << 1) ^ (h3 << 2) ^ (h4 << 3);
        }
    };
}
