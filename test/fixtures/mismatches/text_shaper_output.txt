#pragma once

#include "text_types.hpp"
#include "freetype_face.hpp"
#include <hb.h>
#include <hb-ft.h>
#include <memory>
#include <string>
#include <string_view>
#include <vector>
#include <expected>

& operator=(const HarfBuzzBuffer&) = delete;
    HarfBuzzBuffer(HarfBuzzBuffer&&) noexcept;
    & operator=(HarfBuzzBuffer&&) noexcept;

    // Установить направление и язык
    void set_direction(TextDirection direction);
    void set_script(Script script);
    void set_language(const std::string& language);

    // Добавить текст в буфер
    void add_utf8(std::string_view text);
    void clear();

    // Получить shaped glyphs
    std::vector<ShapedGlyph> get_glyphs() const;

    hb_buffer_t* handle() const { return buffer_; }

private:
    HarfBuzzBuffer() = default;
    hb_buffer_t* buffer_ {nullptr};
};

// RAII wrapper для hb_font_t
& operator=(const HarfBuzzFont&) = delete;
    HarfBuzzFont(HarfBuzzFont&&) noexcept;
    & operator=(HarfBuzzFont&&) noexcept;

    // Установить размер шрифта
    void set_scale(int x_ppem, int y_ppem);

    hb_font_t* handle() const { return font_; }

private:
    HarfBuzzFont() = default;
    hb_font_t* font_ {nullptr};
};

// Главный класс для text shaping
class TextShaper {
public:
    TextShaper() = default;

    // Shape текст с заданным шрифтом
    std::expected<std::vector<ShapedGlyph>, ShapingError>
    shape(FreeTypeFace& face,
          uint16_t size_px,
          std::string_view text,
          const ShapingOptions& options = {});

    // Shape с предсозданным HarfBuzz font
    std::expected<std::vector<ShapedGlyph>, ShapingError>
    shape(HarfBuzzFont& hb_font,
          std::string_view text,
          const ShapingOptions& options = {});

private:
    void apply_features(hb_buffer_t* buffer, const ShapingOptions& options);
};

// Утилиты для конвертации типов
namespace shaping_utils {
    hb_direction_t to_hb_direction(TextDirection dir);
    hb_script_t to_hb_script(Script script);
    hb_language_t to_hb_language(const std::string& lang);

    // Автоопределение направления и скрипта по Unicode
    TextDirection detect_direction(std::string_view text);
    Script detect_script(std::string_view text);
}

} // namespace gtkgl::text
