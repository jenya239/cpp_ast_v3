#include <gtk/gtk.h>
#include <epoxy/gl.h>
#include <iostream>
#include <memory>
#include <map>
#include <vector>
#include <string>
#include <functional>
#include "demos/animated_triangle_demo_gtk4.hpp"
#include "demos/rotating_cube_demo_gtk4.hpp"
#include "demos/building_house_demo_gtk4.hpp"
#include "demos/text_rendering_demo_gtk4.hpp"

using namespace gtkgl;

// Simple DemoManager for GTK4
class DemoManagerGTK4 {
public:
    struct DemoInfo {
        std::string id;
        std::string name;
        std::string description;
        std::string category;
        std::function<std::shared_ptr<demos::DemoScene>()> factory;
    };

    void register_demo(const std::string& id,
                      const std::string& name,
                      const std::string& description,
                      const std::string& category,
                      std::function<std::shared_ptr<demos::DemoScene>()> factory) {
        demos_[id] = DemoInfo{id, name, description, category, factory};
    }

    bool activate_demo(const std::string& id) {
        auto it = demos_.find(id);
        if (it == demos_.end()) {
            return false;
        }

        current_demo_ = it->second.factory();
        current_id_ = id;
        return true;
    }

    demos::DemoScene* current_demo() const {
        return current_demo_.get();
    }

    const std::string& current_id() const {
        return current_id_;
    }

    const std::map<std::string, DemoInfo>& all_demos() const {
        return demos_;
    }

private:
    std::map<std::string, DemoInfo> demos_;
    std::shared_ptr<demos::DemoScene> current_demo_;
    std::string current_id_;
};

// Global state
static DemoManagerGTK4 g_demo_manager;
static GtkWidget* g_gl_area = nullptr;
static GtkListBox* g_demo_list = nullptr;
static GtkTextView* g_log_view = nullptr;
static bool g_gl_initialized = false;
static bool g_need_demo_init = false;

// Helper function to log messages (extern for demos)
;
    }

    GtkTextBuffer* buffer = gtk_text_view_get_buffer(g_log_view);
    GtkTextIter iter;
    gtk_text_buffer_get_end_iter(buffer, &iter);

    std::string msg = message + "\n";
    gtk_text_buffer_insert(buffer, &iter, msg.c_str(), -1);

    // Auto-scroll to bottom
    GtkTextMark* mark = gtk_text_buffer_get_insert(buffer);
    gtk_text_view_scroll_to_mark(g_log_view, mark, 0.0, FALSE, 0.0, 0.0);
}

// GL callbacks
const char*>(glGetString(GL_VERSION))));
    const char*>(glGetString(GL_RENDERER))));

    g_gl_initialized = true;

    // Initialize current demo
    auto* demo = g_demo_manager.current_demo()) {
        demo->on_realize(area);
    }
}

auto* demo = g_demo_manager.current_demo()) {
            demo->on_realize(area);
            g_need_demo_init = false;
        }
    }

    auto* demo = g_demo_manager.current_demo()) {
        demo->on_render(area, context);
    } else {
        // Fallback: clear to dark background
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    return TRUE;
}

auto* demo = g_demo_manager.current_demo()) {
        demo->on_resize(width, height);
    }
}

// Demo selection callback
;
    }

    const char* demo_id = (const char*)g_object_get_data(G_OBJECT(row), "demo-id");
    ;
    }

    auto it = g_demo_manager.all_demos().find(demo_id);
    if (it != g_demo_manager.all_demos().end()) {
        log_message("ðŸ”„ ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð½Ð°: " + it->second.name);
    }

    // Clean up old demo if GL is initialized
    if (g_gl_initialized && g_demo_manager.current_demo()) {
        gtk_gl_area_make_current(GTK_GL_AREA(g_gl_area));
        g_demo_manager.current_demo()->on_unrealize(GTK_GL_AREA(g_gl_area));
    }

    // Activate new demo
    if (g_demo_manager.activate_demo(demo_id)) {
        g_need_demo_init = true;

        // Update depth buffer setting based on demo category
        auto it = g_demo_manager.all_demos().find(demo_id);
        if (it != g_demo_manager.all_demos().end()) {
            bool needs_depth = (it->second.category == "3D");
            gtk_gl_area_set_has_depth_buffer(GTK_GL_AREA(g_gl_area), needs_depth);
            log_message("ðŸ“Š Depth buffer: " + std::string(needs_depth ? "Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½" : "Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½"));
        }

        gtk_gl_area_queue_render(GTK_GL_AREA(g_gl_area));
    }
}

// Create demo selector widget
const auto& [id, info] : g_demo_manager.all_demos()) {
        GtkWidget* row = gtk_list_box_row_new();
        g_object_set_data_full(G_OBJECT(row), "demo-id", g_strdup(id.c_str()), g_free);

        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
        gtk_widget_set_margin_start(box, 10);
        gtk_widget_set_margin_end(box, 10);
        gtk_widget_set_margin_top(box, 8);
        gtk_widget_set_margin_bottom(box, 8);

        GtkWidget* name_label = gtk_label_new(info.name.c_str());
        gtk_widget_set_halign(name_label, GTK_ALIGN_START);
        gtk_widget_add_css_class(name_label, "title-4");

        GtkWidget* desc_label = gtk_label_new(info.description.c_str());
        gtk_widget_set_halign(desc_label, GTK_ALIGN_START);
        gtk_label_set_wrap(GTK_LABEL(desc_label), TRUE);
        gtk_label_set_max_width_chars(GTK_LABEL(desc_label), 30);
        gtk_widget_add_css_class(desc_label, "dim-label");
        gtk_widget_add_css_class(desc_label, "caption");

        GtkWidget* category_label = gtk_label_new(info.category.c_str());
        gtk_widget_set_halign(category_label, GTK_ALIGN_START);
        gtk_widget_add_css_class(category_label, "accent");
        gtk_widget_add_css_class(category_label, "caption");

        gtk_box_append(GTK_BOX(box), name_label);
        gtk_box_append(GTK_BOX(box), desc_label);
        gtk_box_append(GTK_BOX(box), category_label);

        gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(row), box);
        gtk_list_box_append(GTK_LIST_BOX(list_box), row);

        index++;
    }

    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled), list_box);

    return scrolled;
}

// ÐœÐ¸Ð½Ð¸Ð¼Ð°Ð»ÑŒÐ½Ð¾Ðµ GTK4 Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ OpenGL
[](gpointer data) -> gboolean {
        if (auto* demo = g_demo_manager.current_demo()) {
            demo->update(0.016f);  // ~60 FPS
        }
        gtk_gl_area_queue_render(GTK_GL_AREA(data));
        return G_SOURCE_CONTINUE;
    }, gl_area);

    // Activate first demo
    [](gpointer) -> gboolean {
        if (!g_demo_manager.all_demos().empty()) {
            // Select first row
            GtkListBoxRow* first_row = gtk_list_box_get_row_at_index(g_demo_list, 0);
            if (first_row) {
                gtk_list_box_select_row(g_demo_list, first_row);
                on_demo_selected(g_demo_list, first_row, nullptr);
            }
        }
        return FALSE;
    }, nullptr);
}

[]() { return std::make_shared<demos::AnimatedTriangleDemoGTK4>(); }
    );

    []() { return std::make_shared<demos::RotatingCubeDemoGTK4>(); }
    );

    []() { return std::make_shared<demos::BuildingHouseDemoGTK4>(); }
    );

    []() { return std::make_shared<demos::TextRenderingDemoGTK4>(); }
    );

    // Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ GTK4 Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
    GtkApplication* app = gtk_application_new(
        "com.example.gtk4test",
        G_APPLICATION_DEFAULT_FLAGS
    );

    g_signal_connect(app, "activate", G_CALLBACK(on_activate), nullptr);

    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}
