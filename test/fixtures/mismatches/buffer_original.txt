#pragma once

#include <epoxy/gl.h>
#include <vector>
#include <span>

namespace gtkgl::gl {

/**
 * RAII wrapper for OpenGL Vertex Array Object
 */
class VertexArray {
public:
    VertexArray();
    ~VertexArray();

    // No copy
    VertexArray(const VertexArray&) = delete;
    VertexArray& operator=(const VertexArray&) = delete;

    // Move semantics
    VertexArray(VertexArray&& other) noexcept;
    VertexArray& operator=(VertexArray&& other) noexcept;

    void bind() const;
    void unbind() const;

    GLuint handle() const noexcept { return vao_; }
    bool is_valid() const noexcept { return vao_ != 0; }

private:
    GLuint vao_ = 0;
};

/**
 * RAII wrapper for OpenGL Buffer Object
 */
class Buffer {
public:
    enum class Type {
        Array = GL_ARRAY_BUFFER,
        ElementArray = GL_ELEMENT_ARRAY_BUFFER
    };

    enum class Usage {
        Static = GL_STATIC_DRAW,
        Dynamic = GL_DYNAMIC_DRAW,
        Stream = GL_STREAM_DRAW
    };

    explicit Buffer(Type type);
    ~Buffer();

    // No copy
    Buffer(const Buffer&) = delete;
    Buffer& operator=(const Buffer&) = delete;

    // Move semantics
    Buffer(Buffer&& other) noexcept;
    Buffer& operator=(Buffer&& other) noexcept;

    void bind() const;
    void unbind() const;

    template<typename T>
    void data(std::span<const T> data, Usage usage = Usage::Static) {
        bind();
        glBufferData(static_cast<GLenum>(type_),
                     data.size_bytes(),
                     data.data(),
                     static_cast<GLenum>(usage));
    }

    GLuint handle() const noexcept { return buffer_; }
    bool is_valid() const noexcept { return buffer_ != 0; }

private:
    GLuint buffer_ = 0;
    Type type_;
};

} // namespace gtkgl::gl
