#include "demos/demo_manager.hpp"
#include <algorithm>
#include <iostream>

namespace gtkgl::demos {

void DemoManager::register_demo(const std::string& id, FactoryFunc factory) {
    factories_[id] = std::move(factory);
}

bool DemoManager::activate_demo(const std::string& id) {
    auto it = factories_.find(id);
    if (it == factories_.end()) {
        std::cerr << "Demo '" << id << "' not found" << std::endl;
        return false;
    }

    // Create new demo instance
    current_demo_ = it->second();

    // Notify callback
    if (change_callback_) {
        change_callback_(current_demo_.get());
    }

    return true;
}

std::vector<std::string> DemoManager::demo_ids() const {
    std::vector<std::string> ids;
    ids.reserve(factories_.size());

    for (const auto& [id, _] : factories_) {
        ids.push_back(id);
    }

    return ids;
}

std::optional<DemoManager::DemoInfo> DemoManager::get_demo_info(const std::string& id) const {
    auto it = factories_.find(id);
    if (it == factories_.end()) {
        return std::nullopt;
    }

    // Create temporary instance to get metadata
    auto temp_demo = it->second();

    return DemoInfo{
        .id = id,
        .name = temp_demo->name(),
        .description = temp_demo->description(),
        .category = temp_demo->category()
    };
}

std::vector<DemoManager::DemoInfo> DemoManager::all_demos() const {
    std::vector<DemoInfo> infos;
    infos.reserve(factories_.size());

    for (const auto& [id, _] : factories_) {
        if (auto info = get_demo_info(id)) {
            infos.push_back(*info);
        }
    }

    // Sort by category, then by name
    std::sort(infos.begin(), infos.end(), [](const auto& a, const auto& b) {
        if (a.category != b.category) {
            return a.category < b.category;
        }
        return a.name < b.name;
    });

    return infos;
}

} // namespace gtkgl::demos
