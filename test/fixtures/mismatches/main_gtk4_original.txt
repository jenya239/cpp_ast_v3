#include <gtk/gtk.h>
#include <epoxy/gl.h>
#include <iostream>
#include <memory>
#include <map>
#include <vector>
#include <string>
#include <functional>
#include "demos/animated_triangle_demo_gtk4.hpp"
#include "demos/rotating_cube_demo_gtk4.hpp"
#include "demos/building_house_demo_gtk4.hpp"
#include "demos/text_rendering_demo_gtk4.hpp"

using namespace gtkgl;

// Simple DemoManager for GTK4
class DemoManagerGTK4 {
public:
    struct DemoInfo {
        std::string id;
        std::string name;
        std::string description;
        std::string category;
        std::function<std::shared_ptr<demos::DemoScene>()> factory;
    };

    void register_demo(const std::string& id,
                      const std::string& name,
                      const std::string& description,
                      const std::string& category,
                      std::function<std::shared_ptr<demos::DemoScene>()> factory) {
        demos_[id] = DemoInfo{id, name, description, category, factory};
    }

    bool activate_demo(const std::string& id) {
        auto it = demos_.find(id);
        if (it == demos_.end()) {
            return false;
        }

        current_demo_ = it->second.factory();
        current_id_ = id;
        return true;
    }

    demos::DemoScene* current_demo() const {
        return current_demo_.get();
    }

    const std::string& current_id() const {
        return current_id_;
    }

    const std::map<std::string, DemoInfo>& all_demos() const {
        return demos_;
    }

private:
    std::map<std::string, DemoInfo> demos_;
    std::shared_ptr<demos::DemoScene> current_demo_;
    std::string current_id_;
};

// Global state
static DemoManagerGTK4 g_demo_manager;
static GtkWidget* g_gl_area = nullptr;
static GtkListBox* g_demo_list = nullptr;
static GtkTextView* g_log_view = nullptr;
static bool g_gl_initialized = false;
static bool g_need_demo_init = false;

// Helper function to log messages (extern for demos)
void log_message(const std::string& message) {
    if (!g_log_view) {
        return;
    }

    GtkTextBuffer* buffer = gtk_text_view_get_buffer(g_log_view);
    GtkTextIter iter;
    gtk_text_buffer_get_end_iter(buffer, &iter);

    std::string msg = message + "\n";
    gtk_text_buffer_insert(buffer, &iter, msg.c_str(), -1);

    // Auto-scroll to bottom
    GtkTextMark* mark = gtk_text_buffer_get_insert(buffer);
    gtk_text_view_scroll_to_mark(g_log_view, mark, 0.0, FALSE, 0.0, 0.0);
}

// GL callbacks
static void on_gl_realize(GtkGLArea* area, [[maybe_unused]] gpointer user_data) {
    gtk_gl_area_make_current(area);

    log_message("üé® OpenGL –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å–æ–∑–¥–∞–Ω");
    log_message("üìä GL –≤–µ—Ä—Å–∏—è: " + std::string(reinterpret_cast<const char*>(glGetString(GL_VERSION))));
    log_message("üñ• GL —Ä–µ–Ω–¥–µ—Ä–µ—Ä: " + std::string(reinterpret_cast<const char*>(glGetString(GL_RENDERER))));

    g_gl_initialized = true;

    // Initialize current demo
    if (auto* demo = g_demo_manager.current_demo()) {
        demo->on_realize(area);
    }
}

static gboolean on_gl_render([[maybe_unused]] GtkGLArea* area,
                             [[maybe_unused]] GdkGLContext* context,
                             [[maybe_unused]] gpointer user_data) {
    // Initialize demo if needed
    if (g_need_demo_init) {
        if (auto* demo = g_demo_manager.current_demo()) {
            demo->on_realize(area);
            g_need_demo_init = false;
        }
    }

    if (auto* demo = g_demo_manager.current_demo()) {
        demo->on_render(area, context);
    } else {
        // Fallback: clear to dark background
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    return TRUE;
}

static void on_gl_resize(GtkGLArea* area, gint width, gint height, [[maybe_unused]] gpointer user_data) {
    // GL context is already current during resize signal
    gtk_gl_area_make_current(area);

    if (auto* demo = g_demo_manager.current_demo()) {
        demo->on_resize(width, height);
    }
}

// Demo selection callback
static void on_demo_selected([[maybe_unused]] GtkListBox* box, GtkListBoxRow* row, [[maybe_unused]] gpointer user_data) {
    if (!row) {
        return;
    }

    const char* demo_id = (const char*)g_object_get_data(G_OBJECT(row), "demo-id");
    if (!demo_id) {
        return;
    }

    auto it = g_demo_manager.all_demos().find(demo_id);
    if (it != g_demo_manager.all_demos().end()) {
        log_message("üîÑ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞: " + it->second.name);
    }

    // Clean up old demo if GL is initialized
    if (g_gl_initialized && g_demo_manager.current_demo()) {
        gtk_gl_area_make_current(GTK_GL_AREA(g_gl_area));
        g_demo_manager.current_demo()->on_unrealize(GTK_GL_AREA(g_gl_area));
    }

    // Activate new demo
    if (g_demo_manager.activate_demo(demo_id)) {
        g_need_demo_init = true;

        // Update depth buffer setting based on demo category
        auto it = g_demo_manager.all_demos().find(demo_id);
        if (it != g_demo_manager.all_demos().end()) {
            bool needs_depth = (it->second.category == "3D");
            gtk_gl_area_set_has_depth_buffer(GTK_GL_AREA(g_gl_area), needs_depth);
            log_message("üìä Depth buffer: " + std::string(needs_depth ? "–≤–∫–ª—é—á–µ–Ω" : "–æ—Ç–∫–ª—é—á–µ–Ω"));
        }

        gtk_gl_area_queue_render(GTK_GL_AREA(g_gl_area));
    }
}

// Create demo selector widget
static GtkWidget* create_demo_selector() {
    GtkWidget* scrolled = gtk_scrolled_window_new();
    gtk_widget_set_size_request(scrolled, 280, -1);
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled),
                                   GTK_POLICY_NEVER,
                                   GTK_POLICY_AUTOMATIC);

    GtkWidget* list_box = gtk_list_box_new();
    g_demo_list = GTK_LIST_BOX(list_box);
    gtk_list_box_set_selection_mode(GTK_LIST_BOX(list_box), GTK_SELECTION_SINGLE);

    g_signal_connect(list_box, "row-activated", G_CALLBACK(on_demo_selected), nullptr);

    // Populate with demos
    int index = 0;
    for (const auto& [id, info] : g_demo_manager.all_demos()) {
        GtkWidget* row = gtk_list_box_row_new();
        g_object_set_data_full(G_OBJECT(row), "demo-id", g_strdup(id.c_str()), g_free);

        GtkWidget* box = gtk_box_new(GTK_ORIENTATION_VERTICAL, 5);
        gtk_widget_set_margin_start(box, 10);
        gtk_widget_set_margin_end(box, 10);
        gtk_widget_set_margin_top(box, 8);
        gtk_widget_set_margin_bottom(box, 8);

        GtkWidget* name_label = gtk_label_new(info.name.c_str());
        gtk_widget_set_halign(name_label, GTK_ALIGN_START);
        gtk_widget_add_css_class(name_label, "title-4");

        GtkWidget* desc_label = gtk_label_new(info.description.c_str());
        gtk_widget_set_halign(desc_label, GTK_ALIGN_START);
        gtk_label_set_wrap(GTK_LABEL(desc_label), TRUE);
        gtk_label_set_max_width_chars(GTK_LABEL(desc_label), 30);
        gtk_widget_add_css_class(desc_label, "dim-label");
        gtk_widget_add_css_class(desc_label, "caption");

        GtkWidget* category_label = gtk_label_new(info.category.c_str());
        gtk_widget_set_halign(category_label, GTK_ALIGN_START);
        gtk_widget_add_css_class(category_label, "accent");
        gtk_widget_add_css_class(category_label, "caption");

        gtk_box_append(GTK_BOX(box), name_label);
        gtk_box_append(GTK_BOX(box), desc_label);
        gtk_box_append(GTK_BOX(box), category_label);

        gtk_list_box_row_set_child(GTK_LIST_BOX_ROW(row), box);
        gtk_list_box_append(GTK_LIST_BOX(list_box), row);

        index++;
    }

    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled), list_box);

    return scrolled;
}

// –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ GTK4 –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å OpenGL
static void on_activate(GtkApplication* app, [[maybe_unused]] gpointer user_data) {
    // –°–æ–∑–¥–∞–µ–º –æ–∫–Ω–æ
    GtkWidget* window = gtk_application_window_new(app);
    gtk_window_set_title(GTK_WINDOW(window), "GTK4+OpenGL Demo Framework");
    gtk_window_set_default_size(GTK_WINDOW(window), 1200, 700);

    // Main horizontal box
    GtkWidget* main_box = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 10);
    gtk_widget_set_margin_start(main_box, 10);
    gtk_widget_set_margin_end(main_box, 10);
    gtk_widget_set_margin_top(main_box, 10);
    gtk_widget_set_margin_bottom(main_box, 10);

    // Left: Demo selector
    GtkWidget* demo_selector = create_demo_selector();

    // Center: GLArea
    GtkWidget* gl_area = gtk_gl_area_new();
    g_gl_area = gl_area;
    gtk_widget_set_hexpand(gl_area, TRUE);
    gtk_widget_set_vexpand(gl_area, TRUE);
    gtk_gl_area_set_has_depth_buffer(GTK_GL_AREA(gl_area), FALSE);  // Will be set per-demo
    gtk_gl_area_set_auto_render(GTK_GL_AREA(gl_area), TRUE);

    g_signal_connect(gl_area, "realize", G_CALLBACK(on_gl_realize), nullptr);
    g_signal_connect(gl_area, "render", G_CALLBACK(on_gl_render), nullptr);
    g_signal_connect(gl_area, "resize", G_CALLBACK(on_gl_resize), nullptr);

    // Mouse events for camera control
    GtkGesture* drag_gesture = gtk_gesture_drag_new();
    gtk_widget_add_controller(gl_area, GTK_EVENT_CONTROLLER(drag_gesture));

    auto on_drag_begin = +[](GtkGestureDrag*, gdouble x, gdouble y, gpointer) {
        if (auto* demo = g_demo_manager.current_demo()) {
            if (demo->category() == "3D") {
                if (auto* cube = dynamic_cast<demos::RotatingCubeDemoGTK4*>(demo)) {
                    cube->on_mouse_press(x, y);
                } else if (auto* house = dynamic_cast<demos::BuildingHouseDemoGTK4*>(demo)) {
                    house->on_mouse_press(x, y);
                }
            }
        }
    };

    auto on_drag_update = +[](GtkGestureDrag* gesture, gdouble offset_x, gdouble offset_y, gpointer) {
        if (auto* demo = g_demo_manager.current_demo()) {
            if (demo->category() == "3D") {
                gdouble start_x, start_y;
                gtk_gesture_drag_get_start_point(gesture, &start_x, &start_y);
                if (auto* cube = dynamic_cast<demos::RotatingCubeDemoGTK4*>(demo)) {
                    cube->on_mouse_move(start_x + offset_x, start_y + offset_y);
                } else if (auto* house = dynamic_cast<demos::BuildingHouseDemoGTK4*>(demo)) {
                    house->on_mouse_move(start_x + offset_x, start_y + offset_y);
                }
            }
        }
    };

    auto on_drag_end = +[](GtkGestureDrag*, gdouble x, gdouble y, gpointer) {
        if (auto* demo = g_demo_manager.current_demo()) {
            if (demo->category() == "3D") {
                if (auto* cube = dynamic_cast<demos::RotatingCubeDemoGTK4*>(demo)) {
                    cube->on_mouse_release(x, y);
                } else if (auto* house = dynamic_cast<demos::BuildingHouseDemoGTK4*>(demo)) {
                    house->on_mouse_release(x, y);
                }
            }
        }
    };

    g_signal_connect(drag_gesture, "drag-begin", G_CALLBACK(on_drag_begin), nullptr);
    g_signal_connect(drag_gesture, "drag-update", G_CALLBACK(on_drag_update), nullptr);
    g_signal_connect(drag_gesture, "drag-end", G_CALLBACK(on_drag_end), nullptr);

    // Right: Log view (simple text view for now)
    GtkWidget* log_scrolled = gtk_scrolled_window_new();
    gtk_widget_set_size_request(log_scrolled, 280, -1);
    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(log_scrolled),
                                   GTK_POLICY_AUTOMATIC,
                                   GTK_POLICY_AUTOMATIC);

    GtkWidget* log_view = gtk_text_view_new();
    g_log_view = GTK_TEXT_VIEW(log_view);
    gtk_text_view_set_editable(GTK_TEXT_VIEW(log_view), FALSE);
    gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(log_view), GTK_WRAP_WORD);
    gtk_widget_add_css_class(log_view, "monospace");
    gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(log_scrolled), log_view);

    // Pack widgets
    gtk_box_append(GTK_BOX(main_box), demo_selector);
    gtk_box_append(GTK_BOX(main_box), gl_area);
    gtk_box_append(GTK_BOX(main_box), log_scrolled);

    gtk_window_set_child(GTK_WINDOW(window), main_box);
    gtk_window_present(GTK_WINDOW(window));

    // Initial log messages
    log_message("‚ú® –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ");
    log_message("üì¶ GTK –≤–µ—Ä—Å–∏—è: " + std::to_string(gtk_get_major_version()) + "." + std::to_string(gtk_get_minor_version()));
    log_message("üéØ –î–µ–º–æ –¥–æ—Å—Ç—É–ø–Ω–æ: " + std::to_string(g_demo_manager.all_demos().size()));

    // –¢–∞–π–º–µ—Ä –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
    g_timeout_add(16, [](gpointer data) -> gboolean {
        if (auto* demo = g_demo_manager.current_demo()) {
            demo->update(0.016f);  // ~60 FPS
        }
        gtk_gl_area_queue_render(GTK_GL_AREA(data));
        return G_SOURCE_CONTINUE;
    }, gl_area);

    // Activate first demo
    g_idle_add([](gpointer) -> gboolean {
        if (!g_demo_manager.all_demos().empty()) {
            // Select first row
            GtkListBoxRow* first_row = gtk_list_box_get_row_at_index(g_demo_list, 0);
            if (first_row) {
                gtk_list_box_select_row(g_demo_list, first_row);
                on_demo_selected(g_demo_list, first_row, nullptr);
            }
        }
        return FALSE;
    }, nullptr);
}

int main(int argc, char* argv[]) {
    // Register demos
    g_demo_manager.register_demo(
        "triangle",
        "–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫",
        "–ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫ —Å –¥–≤–∏–∂–µ–Ω–∏–µ–º –∏ —Å–º–µ–Ω–æ–π —Ü–≤–µ—Ç–∞",
        "2D",
        []() { return std::make_shared<demos::AnimatedTriangleDemoGTK4>(); }
    );

    g_demo_manager.register_demo(
        "cube",
        "–í—Ä–∞—â–∞—é—â–∏–π—Å—è –∫—É–±",
        "3D –∫—É–± —Å –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–æ–π, –≥—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–º –æ—Å–≤–µ—â–µ–Ω–∏–µ–º –∏ –ø–ª–∞–≤–Ω—ã–º –≤—Ä–∞—â–µ–Ω–∏–µ–º",
        "3D",
        []() { return std::make_shared<demos::RotatingCubeDemoGTK4>(); }
    );

    g_demo_manager.register_demo(
        "house",
        "–°–±–æ—Ä–∫–∞ –¥–æ–º–∏–∫–∞",
        "–ë–ª–æ–∫–∏ –≤—ã–ª–µ—Ç–∞—é—Ç –∏ —Å–æ–±–∏—Ä–∞—é—Ç—Å—è –≤ –¥–æ–º–∏–∫ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–∞–º–µ—Ä–æ–π",
        "3D",
        []() { return std::make_shared<demos::BuildingHouseDemoGTK4>(); }
    );

    g_demo_manager.register_demo(
        "text",
        "–†–µ–Ω–¥–µ—Ä–∏–Ω–≥ —Ç–µ–∫—Å—Ç–∞",
        "OpenGL text rendering: FreeType + HarfBuzz + Texture Atlas",
        "Text",
        []() { return std::make_shared<demos::TextRenderingDemoGTK4>(); }
    );

    // –°–æ–∑–¥–∞–µ–º GTK4 –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    GtkApplication* app = gtk_application_new(
        "com.example.gtk4test",
        G_APPLICATION_DEFAULT_FLAGS
    );

    g_signal_connect(app, "activate", G_CALLBACK(on_activate), nullptr);

    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);

    return status;
}
