# Документ для ИИ-агента: Проверка архитектуры парсера C++ на Ruby

## Цель
Обеспечить проверку архитектуры парсера C++ (написанного на Ruby) с возможностью **байт-идентичной регенерации исходного текста** после построения и модификации дерева. Это значит: `print(parse(src)) == src`.

## Основные принципы

1. **Lossless Concrete Syntax Tree (CST)**
   - Каждый токен хранит **leading trivia** и **trailing trivia** (пробелы, комментарии, переводы строк, препроцессорные пробелы и т.д.).
   - Trivia — это отдельные объекты, ссылающиеся на **байтовые диапазоны** исходного файла, а не нормализованные строки.
   - Печать исходника = конкатенация `leading + token_text + trailing`.

2. **Green/Red дерево**
   - **Green (immutable)**: структура + токены (с trivia и байтовыми диапазонами). Можно шарить и переиспользовать.
   - **Red (mutable)**: обертка над Green, с указателями на родителя и детей. Используется для навигации и правок.

3. **Парсер**
   - Строит полное CST: сохраняет все синтаксические символы (`;`, `,`, `()`, `::`, `<>`) как узлы или токены.
   - Не выполняет препроцессор (директивы `#include`, `#define`, `#if` → отдельные токены с trivia).

4. **Round-trip печать**
   - Проход по всем токенам в порядке исходника.
   - Для каждого токена: вывести `leading`, `text`, `trailing`.
   - Никаких нормализаций.

5. **Редактирование**
   - При изменении узла создаётся новый Green-подузел, неизменённые токены и trivia переиспользуются.
   - Для новых токенов:
     - унаследовать `leading` у соседа (или пусто),
     - переносы и пробелы добавлять как trivia, а не в `text`.

6. **Инварианты для проверки**
   - Токен всегда знает свой **leading** и **trailing**.
   - Trivia всегда ссылаются на диапазон исходника.
   - `print(parse(src))` должно возвращать **байт-в-байт** то же самое.

## Потенциальные проблемы и проверки

1. **Форматирование**
   - Разные переводы строк (`\n`, `\r\n`, `\r`) сохраняются в trivia.
   - BOM и shebang сохраняются как отдельные trivia.

2. **Комментарии**
   - Однострочные `//` и многострочные `/* ... */` должны оставаться trivia.
   - Проверить комментарии внутри макросов.

3. **Проблемные зоны C++**
   - Сырые строки (`R"(... )"`).
   - Тритографы/диграфы (`??/` → `\`).
   - `>>` в шаблонных аргументах.
   - `\`-NL в макросах.
   - `##` и `#` в макросах.

4. **Препроцессор**
   - Директивы токенизируются, но не исполняются.
   - Пробелы после `#` сохраняются.

5. **Тестирование**
   - `round_trip_test`: для корпуса исходников C++ сравнить `print(parse(src))` и `src`.
   - `local_edit_test`: изменить один узел → проверить, что меняется только соответствующий диапазон.
   - `fuzzing_test`: случайные пробелы/комментарии/директивы.

## Альтернативные архитектуры (для сравнения)

1. **Patch-based**: хранить исходник как «истину» и применять патчи.  
   Недостаток — сложно для сложных правок.

2. **Pretty-printer + comment attachment**: печатать AST по стилю.  
   Недостаток — не гарантирует идентичности исходника.

3. **CST→AST гибрид**: CST для round-trip, AST для анализа.  
   Часто оптимальный компромисс.

## Рекомендации для ИИ-агента

При проверке архитектуры:
1. Убедись, что токены несут trivia (leading/trailing).
2. Проверь, что печать реализована как обход токенов, а не форматтер.
3. Убедись, что парсер хранит все разделители (`;`, `,`, скобки и т.д.).
4. Убедись, что препроцессорные директивы хранятся в токенах.
5. Убедись, что тесты `round_trip` и `local_edit` есть и проходят.
6. Сравни с альтернативами и зафиксируй, почему выбранный подход даёт надёжный round-trip.

---

## Итог
Основное решение: **lossless CST с trivia (green/red дерево)**. Это наиболее надёжный и масштабируемый метод для идентичной регенерации исходника и поддержки редактирования. Все проверки ИИ-агент должен строить вокруг сохранности trivia и точности печати.

