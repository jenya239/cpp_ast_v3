# Анализ архитектуры парсера C++ v3

Дата: 2025-10-10
Цель: Проверка соответствия архитектуры принципам lossless CST из `cpp_parser_arch.md`

## 1. Инвентаризация текущей архитектуры

### 1.1 Структура Token

**Файл**: `lib/cpp_ast/lexer/token.rb`

```ruby
class Token
  attr_reader :kind, :lexeme, :line, :column
  TRIVIA_KINDS = [:whitespace, :comment, :newline, :preprocessor, :attribute]
end
```

**Характеристики**:
- ✅ Хранит kind (тип токена)
- ✅ Хранит lexeme (текст токена)
- ✅ Хранит позицию (line, column)
- ❌ НЕ хранит leading_trivia
- ❌ НЕ хранит trailing_trivia
- ❌ НЕ хранит байтовые диапазоны (source_range)

### 1.2 Обработка trivia в лексере

**Файл**: `lib/cpp_ast/lexer/lexer.rb`

**Подход**: Trivia создаются как отдельные токены со специальными kind:
- `:whitespace` - пробелы и табы
- `:newline` - переводы строк
- `:comment` - однострочные `//` и многострочные `/* */`
- `:preprocessor` - директивы `#include`, `#define` и т.д.

**Пример токенизации**:
```cpp
x = 42; // comment
```
Создаёт токены: `identifier(x)`, `whitespace( )`, `equals(=)`, `whitespace( )`, `number(42)`, `semicolon(;)`, `whitespace( )`, `comment(// comment)`, `newline(\n)`

### 1.3 Обработка trivia в парсере

**Файл**: `lib/cpp_ast/parsers/base_parser.rb`

```ruby
def collect_trivia_string
  result = "".dup
  while current_token && Token.trivia?(current_token.kind)
    result << current_token.lexeme
    advance_raw
  end
  result
end
```

**Подход**:
- Парсер проходит через токены-trivia
- Собирает их в строку
- Передаёт строку в узлы как `leading_trivia` или сохраняет в `statement_trailings`

### 1.4 Parent ownership

**Файл**: `lib/cpp_ast/parsers/program_parser.rb`

```ruby
def parse
  statements = []
  statement_trailings = []
  
  leading = collect_trivia_string
  
  until at_end?
    stmt, trailing = parse_statement(leading)
    statements << stmt
    statement_trailings << trailing
    leading = ""
  end
  
  Nodes::Program.new(
    statements: statements,
    statement_trailings: statement_trailings
  )
end
```

**Подход**:
- ✅ Parent (Program) владеет trailing trivia детей
- ✅ Парсеры возвращают кортежи `(node, trailing_trivia)`
- ✅ Parent управляет spacing между детьми

### 1.5 Реализация to_source

**Файл**: `lib/cpp_ast/nodes/statements.rb`

```ruby
class Program < Node
  attr_accessor :statements, :statement_trailings
  
  def to_source
    result = "".dup
    statements.zip(statement_trailings).each do |stmt, trailing|
      result << stmt.to_source << trailing
    end
    result
  end
end

class ExpressionStatement < Statement
  attr_accessor :leading_trivia, :expression
  
  def to_source
    "#{leading_trivia}#{expression.to_source};"
  end
end
```

**Подход**:
- ✅ Конкатенация строк
- ✅ Все пробелы и комментарии сохраняются
- ✅ Nodes не хранят trailing (только leading)
- ✅ Parent управляет spacing

### 1.6 Тестирование round-trip

**Статус тестов**: 481 runs, 630 assertions, 0 failures ✅

**Успешные roundtrip тесты**:
- ✅ Простые присваивания
- ✅ Выражения с операторами
- ✅ Control flow (if, while, for, switch)
- ✅ Функции, классы, структуры
- ✅ Templates
- ✅ Комментарии и пробелы
- ✅ Лямбды
- ✅ Enum
- ✅ Operator overloading в классах (ИСПРАВЛЕНО)

## 2. Сравнение с принципами из cpp_parser_arch.md

### 2.1 Принцип 1: Lossless CST с trivia

**Требование**: Каждый токен хранит leading и trailing trivia

**Текущее состояние**: ❌ ЧАСТИЧНО

- ❌ Token НЕ хранит trivia напрямую
- ✅ Trivia сохраняются как отдельные токены
- ✅ Парсер собирает trivia в строки
- ✅ Узлы хранят leading_trivia
- ✅ Parent хранит trailing через statement_trailings

**Вывод**: Механизм работает, но архитектура отличается от эталона

### 2.2 Принцип 2: Green/Red дерево

**Требование**: Green (immutable) + Red (mutable wrapper)

**Текущее состояние**: ❌ НЕ РЕАЛИЗОВАНО

- ❌ Нет разделения на Green/Red
- ❌ Все узлы mutable (attr_accessor)
- ❌ Нет переиспользования неизменённых узлов

**Вывод**: Не реализовано. Для текущих задач (парсинг + to_source) не критично

### 2.3 Принцип 3: Полное CST

**Требование**: Все синтаксические символы сохранены (`;`, `,`, `()`, `::`, `<>`)

**Текущее состояние**: ✅ СООТВЕТСТВУЕТ

- ✅ Все разделители парсятся
- ✅ Все символы восстанавливаются в to_source
- ✅ Узлы хранят spacing между токенами (keyword_suffix, lparen_suffix и т.д.)

### 2.4 Принцип 4: Round-trip печать

**Требование**: `print(parse(src)) == src` байт-в-байт

**Текущее состояние**: ✅ СООТВЕТСТВУЕТ (99.4%)

- ✅ 478 из 481 тестов проходят
- ✅ Roundtrip работает для большинства конструкций
- ❌ 3 теста падают из-за бага в парсинге operator=

**Вывод**: Архитектура roundtrip работает правильно, есть локальные баги парсера

### 2.5 Принцип 5: Редактирование

**Требование**: При изменении узла переиспользуются неизменённые части

**Текущее состояние**: ❌ НЕ РЕАЛИЗОВАНО

- ❌ Нет механизма редактирования
- ❌ Нет переиспользования токенов/узлов
- ❌ Нет rewriter-ов (папка `rewriters/` пуста)

**Вывод**: Функциональность не реализована. Для будущего расширения

### 2.6 Принцип 6: Инварианты

**Требование**:
- Токен знает свой leading и trailing
- Trivia ссылаются на байтовые диапазоны исходника

**Текущее состояние**: ❌ ЧАСТИЧНО

- ❌ Токен НЕ знает свои trivia (trivia собираются парсером)
- ❌ Trivia как строки, НЕ как байтовые диапазоны
- ✅ Позиция токенов известна (line, column)

## 3. Критичные и некритичные проблемы

### 3.1 КРИТИЧНЫЕ проблемы

#### 3.1.1 Токены без trivia
**Проблема**: Token не хранит leading/trailing trivia

**Влияние**: 
- Архитектура не соответствует эталону
- Нельзя узнать trivia токена без парсера
- Усложняет редактирование

**Приоритет**: СРЕДНИЙ (roundtrip работает, но архитектура не оптимальна)

### 3.2 НЕКРИТИЧНЫЕ проблемы

#### 3.2.1 Нет байтовых диапазонов
**Проблема**: Trivia хранятся как строки, не как диапазоны в source

**Влияние**: 
- Больше памяти (дублирование строк)
- Невозможно эффективное редактирование

**Приоритет**: НИЗКИЙ (работает, оптимизация для будущего)

#### 3.2.2 Нет Green/Red дерева
**Проблема**: Всё mutable, нет переиспользования

**Влияние**: 
- Больше памяти при редактировании
- Нельзя безопасно шарить узлы

**Приоритет**: НИЗКИЙ (редактирование пока не нужно)

#### 3.2.3 Не реализован препроцессор
**Проблема**: `#include`, `#define` и т.д. парсятся как preprocessor trivia, но не как полноценные директивы

**Влияние**: 
- Нельзя анализировать макросы
- Нельзя резолвить includes

**Приоритет**: НИЗКИЙ (для будущих фич)

### 3.3 Что работает ХОРОШО

✅ **Parent ownership** - реализован правильно  
✅ **Round-trip** - работает для 99.4% случаев  
✅ **Все разделители сохраняются** - полное CST  
✅ **Комментарии сохраняются** - inline и block  
✅ **Чистая архитектура** - разделение lexer/parser/nodes  
✅ **Comprehensive тесты** - 481 runs, хорошее покрытие  

## 4. План инкрементальных улучшений

### ~~Уровень 0: Исправление багов~~ ✅ ВЫПОЛНЕНО
**Результат**: Roundtrip 100% (481 тест, 0 failures)

**Исправления**:
1. ✅ Исправлен баг парсинга `operator=` в классах
   - Проблема: парсер ошибочно определял `Buffer& operator=` как конструктор
   - Решение: добавлена lookahead проверка для различения конструкторов от операторов
2. ✅ Все тесты проходят

**Файлы**: `lib/cpp_ast/parsers/statement_parser.rb` (строки 957-972, 1041-1042)

### Уровень 1: Trivia в токенах (РЕКОМЕНДУЕТСЯ)
**Цель**: Привести архитектуру к эталону с минимальными изменениями

**Задачи**:
1. Добавить `leading_trivia` и `trailing_trivia` в Token
2. Изменить лексер: после создания non-trivia токена, собирать следующие trivia как trailing
3. Изменить парсер: использовать `token.leading_trivia` вместо `collect_trivia_string`
4. Упростить узлы: читать trivia из токенов, а не через параметры
5. Обратная совместимость: дефолтные значения для trivia

**Преимущества**:
- Токен знает свои trivia (соответствие эталону)
- Упрощение парсера (меньше collect_trivia_string)
- Проще редактирование (токен самодостаточен)

**Сложность**: СРЕДНЯЯ  
**Время**: 4-6 часов  
**Риски**: Может сломать существующие тесты  
**Файлы**: 
- `lib/cpp_ast/lexer/token.rb` (+10 строк)
- `lib/cpp_ast/lexer/lexer.rb` (~50 строк)
- `lib/cpp_ast/parsers/base_parser.rb` (~30 строк)
- `lib/cpp_ast/nodes/statements.rb` (рефакторинг)

### Уровень 2: Байтовые диапазоны (ОПЦИОНАЛЬНО)
**Цель**: Оптимизация памяти и подготовка к эффективному редактированию

**Задачи**:
1. Добавить `source_range: (start, end)` в Token
2. Создать класс Trivia с kind и source_range
3. Token хранит массивы `leading_trivia: [Trivia]` и `trailing_trivia: [Trivia]`
4. to_source использует source[range] вместо конкатенации строк
5. Хранить исходный source в Program

**Преимущества**:
- Экономия памяти (нет дублирования строк)
- Быстрый to_source (прямой доступ к source)
- Эффективное редактирование (локальные изменения)

**Сложность**: ВЫСОКАЯ  
**Время**: 8-12 часов  
**Риски**: Большой рефакторинг, может сломать многое  
**Файлы**: Почти все файлы

### Уровень 3: Green/Red дерево (ОТЛОЖИТЬ)
**Цель**: Immutable структура для безопасного редактирования

**Задачи**:
1. Создать GreenNode (immutable, sharable)
2. Создать RedNode (mutable wrapper с parent/offset)
3. Парсер строит Green tree
4. Создать фасад для навигации через Red tree
5. Rewriter строит новое Green tree, переиспользуя неизменённые части

**Преимущества**:
- Безопасное редактирование (нельзя сломать исходное дерево)
- Экономия памяти (переиспользование узлов)
- Параллельный доступ (immutable → thread-safe)

**Сложность**: ОЧЕНЬ ВЫСОКАЯ  
**Время**: 20-40 часов  
**Риски**: Полный редизайн архитектуры  
**Когда нужно**: Если понадобится сложное редактирование деревьев

## 5. Рекомендации

### 5.1 ~~Немедленные действия~~ ✅ ВЫПОЛНЕНО
1. ✅ Исправлен баг operator= (Уровень 0)
2. ✅ Тесты: 100% success (481/481)

### 5.2 Краткосрочная перспектива (1-2 недели)
3. Реализовать Уровень 1 (trivia в токенах)
4. Документировать архитектуру после изменений
5. Добавить больше edge-case тестов

### 5.3 Среднесрочная перспектива (1-2 месяца)
6. Добавить поддержку сложных конструкций (concepts, modules, coroutines)
7. Оценить необходимость Уровня 2 (байтовые диапазоны)
8. Начать работу над rewriter-ами

### 5.4 Долгосрочная перспектива (3-6 месяцев)
9. Если нужно редактирование - реализовать Уровень 3 (Green/Red)
10. Полная поддержка C++20/23
11. Производительность и оптимизация памяти

## 6. Выводы

### Текущее состояние: ОТЛИЧНОЕ ✅

Архитектура парсера **функционально соответствует** целям lossless CST:
- Round-trip работает (100% тестов проходит - 481/481) ✅
- Parent ownership реализован правильно
- Все синтаксические элементы сохраняются
- Чистая архитектура с разделением слоёв

### Отличия от эталона: НЕКРИТИЧНЫЕ ⚠️

Архитектура **отличается от эталона** в деталях реализации:
- Trivia как отдельные токены вместо полей в Token
- Строки вместо байтовых диапазонов
- Нет Green/Red разделения

Эти отличия **не мешают** основной функциональности, но делают архитектуру менее "каноничной" и менее подходящей для сложного редактирования.

### Приоритет улучшений:

**~~ВЫСОКИЙ~~**: ~~Уровень 0 (фикс багов)~~ - ✅ ВЫПОЛНЕНО  
**СРЕДНИЙ**: Уровень 1 (trivia в токенах) - ЖЕЛАТЕЛЬНО  
**НИЗКИЙ**: Уровень 2-3 - ОПЦИОНАЛЬНО, ДЛЯ БУДУЩЕГО

### Итоговая оценка: 9/10 ⬆️

Проект **отлично** справляется со своей задачей (roundtrip 100%), имеет чистую архитектуру и comprehensive тесты. Критичный баг исправлен. Инкрементальные улучшения (Уровень 1) помогут приблизить архитектуру к эталонной CST.

