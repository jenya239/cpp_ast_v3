# Управление памятью в Aurora

## Массивы и динамическая память

Aurora компилируется в C++ и использует `std::vector<T>` для массивов. Это означает **автоматическое управление памятью** через механизм RAII.

## Как это работает

### 1. Создание массива

**Aurora код:**
```aurora
fn test() -> i32 =
  let arr = [1, 2, 3, 4, 5];
  arr.length()
```

**Генерируется C++:**
```cpp
int test(){
  return arr.size();
}
```

### 2. Что происходит в runtime

```cpp
// При создании массива:
std::vector<int> arr = std::vector<int>{1, 2, 3, 4, 5};

// Внутри std::vector:
// 1. Конструктор выделяет память на heap через allocator
// 2. Копирует элементы {1, 2, 3, 4, 5} в выделенную память
// 3. Сохраняет указатель на данные, размер и capacity
```

**Структура `std::vector` (упрощённо):**
```cpp
template<typename T>
class vector {
    T* data;        // Указатель на heap память
    size_t size;    // Количество элементов
    size_t capacity;// Выделенная ёмкость

    ~vector() {
        // Деструктор автоматически освобождает память!
        delete[] data;
    }
};
```

### 3. Время жизни и освобождение памяти

**Aurora код:**
```aurora
fn process_data() -> i32 =
  let arr1 = [1, 2, 3];
  let arr2 = [4, 5, 6];
  arr1.length() + arr2.length()
  // Здесь arr1 и arr2 выходят из scope
  // Деструкторы вызываются автоматически
  // Память освобождается без участия программиста
```

**Эквивалент в C++ с явными комментариями:**
```cpp
int process_data() {
    {
        std::vector<int> arr1{1, 2, 3};  // heap memory allocated
        std::vector<int> arr2{4, 5, 6};  // heap memory allocated

        return arr1.size() + arr2.size();

    } // <- arr1.~vector() called automatically
      // <- arr2.~vector() called automatically
      // <- all heap memory freed
}
```

## RAII (Resource Acquisition Is Initialization)

Это фундаментальная идиома C++:

1. **Ресурс захватывается в конструкторе**
   - `std::vector` выделяет память в конструкторе

2. **Ресурс освобождается в деструкторе**
   - `~vector()` освобождает память автоматически

3. **Деструктор вызывается при выходе из scope**
   - Компилятор C++ вставляет вызов деструктора

4. **Никаких утечек памяти**
   - Если нет исключений или других проблем

## Динамические операции

### Push (добавление элемента)

**Aurora:**
```aurora
let arr = [1, 2, 3];
arr.push(4)
```

**C++:**
```cpp
std::vector<int> arr{1, 2, 3};
arr.push_back(4);
```

**Что происходит:**
```cpp
// Если size < capacity:
//   - Просто добавляет элемент
//   - O(1) операция
//
// Если size == capacity:
//   - Выделяет новый буфер (обычно в 2 раза больше)
//   - Копирует старые элементы
//   - Освобождает старый буфер
//   - Добавляет новый элемент
//   - O(n) операция, но амортизированно O(1)
```

### Копирование vs перемещение

**C++11+ использует move semantics:**
```cpp
std::vector<int> arr1{1, 2, 3};
std::vector<int> arr2 = std::move(arr1);  // Перемещение, не копирование
// arr1 теперь пустой
// arr2 владеет данными
// Никакого копирования элементов!
```

## Производительность

### Memory layout
```
std::vector<int> arr{1, 2, 3, 4, 5};

Stack:                          Heap:
┌─────────────┐                ┌───┬───┬───┬───┬───┐
│ data   ────────────────────> │ 1 │ 2 │ 3 │ 4 │ 5 │
├─────────────┤                └───┴───┴───┴───┴───┘
│ size = 5    │                  Непрерывный блок
├─────────────┤                  в памяти - отлично
│ capacity=5  │                  для cache locality!
└─────────────┘
```

### Преимущества

✅ **Cache-friendly**: элементы в непрерывной памяти
✅ **O(1) индексация**: `arr[i]` - прямой доступ
✅ **Автоматическое управление**: нет manual free/delete
✅ **Exception-safe**: деструктор вызывается даже при исключениях

### Недостатки

❌ **Вставка в начало/середину**: O(n) - нужно сдвигать элементы
❌ **Реаллокация**: при переполнении capacity может быть дорогой
❌ **Overhead**: 3 слова (data, size, capacity) на стеке

## Сравнение с другими подходами

### Garbage Collection (Java/Python/JS)

```python
# Python
arr = [1, 2, 3, 4, 5]
# Память управляется GC
# Освобождение происходит когда GC решит
# Непредсказуемые паузы
# Дополнительный overhead на reference counting/tracing
```

### Manual Management (C)

```c
// C
int* arr = malloc(5 * sizeof(int));
// ...
free(arr);  // ОБЯЗАТЕЛЬНО освободить вручную!
// Забыл free? -> Memory leak
// Двойной free? -> Crash
// Use after free? -> Undefined behavior
```

### RAII (C++/Aurora)

```cpp
// C++/Aurora
std::vector<int> arr{1, 2, 3, 4, 5};
// Память освобождается автоматически
// Детерминированное время освобождения
// Нет overhead на GC
// Безопасно и эффективно
```

## Особенности текущей реализации Aurora

### Что работает

✅ Массивы создаются через `std::vector<T>{...}`
✅ Автоматическое управление памятью через RAII
✅ Безопасное копирование и перемещение
✅ Все методы `std::vector` доступны (size, push_back, etc.)

### Ограничения

⚠️ **Нет borrowing/ownership системы** как в Rust
   - Возможны случайные копирования
   - Нет compile-time гарантий от data races

⚠️ **Нет reference counting** как в Swift/Python
   - Невозможно безопасно шарить данные между потоками без явной синхронизации

⚠️ **В let-binding массивы могут копироваться:**
```aurora
let arr1 = [1, 2, 3];
let arr2 = arr1;  // В C++ это КОПИРОВАНИЕ!
arr2.push(4);     // arr1 не изменится
```

### Будущие улучшения

Возможные направления:

1. **Явные указания на владение:**
   ```aurora
   let arr = [1, 2, 3];        // owned
   let ref = &arr;             // borrowed reference
   let moved = move arr;       // move semantics
   ```

2. **Reference counting для shared ownership:**
   ```aurora
   let shared = shared([1, 2, 3]);  // std::shared_ptr<vector<int>>
   ```

3. **Immutable массивы:**
   ```aurora
   let immutable = const([1, 2, 3]);  // const std::vector
   ```

## Резюме

**Для программиста Aurora:**
- ✅ Массивы работают "просто так"
- ✅ Никаких `malloc`/`free`
- ✅ Никаких утечек памяти при нормальном использовании
- ✅ Детерминированное освобождение при выходе из scope
- ✅ Производительность как в C++

**Под капотом:**
- `std::vector<T>` управляет heap памятью
- RAII гарантирует освобождение
- Move semantics для эффективности
- Cache-friendly непрерывное размещение

**Важно помнить:**
- В C++ assignment по умолчанию копирует
- Для больших данных можно использовать move
- Нет runtime overhead (в отличие от GC)
- Детерминированное время освобождения (в отличие от GC)
