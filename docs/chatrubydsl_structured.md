# Ruby DSL для C++ - Структурированный анализ диалога

## Основные концепции

### 1. Ruby DSL для генерации C++ AST
**Цель**: Создать высокоуровневый DSL на Ruby для генерации современного C++ кода без строковых литералов.

**Ключевые особенности**:
- Типобезопасные узлы AST
- Лучшие практики C++ по умолчанию (noexcept, constexpr, RAII)
- Декларативный стиль описания
- Автоматическая генерация современного C++20/23

**Пример синтаксиса**:
```ruby
cpp do
  std.include :vector, :memory
  using :std, :size_t

  ns :app do
    struct :Vec2, final: true do
      field :x, t.f32
      field :y, t.f32
      
      ctor params: [[:f32, :x], [:f32, :y]], constexpr: true, noexcept: true
      
      def_ :len, ret: t.f32, const: true, noexcept: true do
        ret (id(:x)*id(:x) + id(:y)*id(:y)).call(:sqrt)
      end
    end
  end
end
```

### 2. Преимущества DSL подхода

**Практическая выгода**:
- Безошибочная сборка кода
- Единый стиль и лучшие практики "по умолчанию"
- Автоматические миграции
- Инварианты домена
- Рефакторинг "всем проектом"
- Точная структура проектов
- Меньше диффов
- Тестируемость
- Аналитика и статический аудит
- Политики безопасности
- Портирование/мульти-таргет
- Интероп
- Производительность по политике
- Документация "из истины"

**Где особенно полезно**:
- Слой инфраструктуры
- API/SDK и клиентские библиотеки
- Сериализация/схемы
- Embedded/регистры
- Генерация обвязок
- ECS/игровые системы
- GPU/compute каркасы

### 3. Язык Aurora - эволюция DSL

**Концепция**: Отдельный язык, похожий на DSL по структуре, который парсится в свой AST, а затем транслируется в C++ AST.

**Цели**:
- Минимальная, выразительная запись
- Современные best-practices по умолчанию
- ESM-подобные модули
- Без GC; явные "own/borrow" аннотации
- ADT (sum/product), pattern matching
- Дженерики с моноформизацией

**Пример синтаксиса Aurora**:
```aurora
module app/geom

export { Vec2, length, scale, centroid }

type Vec2 = { x: f32, y: f32 }
type Color = enum { Red=1, Green, Blue }

type Shape =
  | Circle { r: f32 }
  | Rect   { w: f32, h: f32 }

fn length(v: Vec2) -> f32 =
  (v.x*v.x + v.y*v.y).sqrt()

fn area(s: Shape) -> f32 =
  match s
    | Circle{r} => 3.14159265 * r*r
    | Rect{w,h} => w*h
```

### 4. Ограничения и сужения относительно C++

**Что намеренно сужаем**:
- Препроцессор (#define, #include-игры)
- Сырые указатели/new/delete/malloc
- Множественное наследование/virtual иерархии
- UB-трюки (reinterpret_cast, type-punning)
- Исключения (по умолчанию запрет)
- SFINAE-акробатика/частичные специализации
- friend, ADL-магия
- mutable/глобальное состояние
- Inline asm/компилерные builtins

**Escape-механизмы**:
- `extern cpp type/function`
- `unsafe cpp { ... }`
- Политики на модуль: `allow_exceptions`, `allow_raw_ptr`

### 5. Отладка и диагностика

**Подходы к отладке**:
- Генерация корректных DWARF-линий
- Прозрачные имена символов
- Стек-трейсы в рантайме
- Linker map (.map) для анализа
- IDE-шагание
- Юнит- и golden-тесты

**Инструменты**:
- Source-map (узел → файл.aur:строка)
- JSON-карта символов
- Скрипт `aur-symbolize`
- Pretty-printers для ADT

### 6. FFI и работа с системными библиотеками

**Подход**: Тонкий FFI + "безопасные" RAII-обёртки.

**Синтаксис для FFI**:
```aurora
@pkg "xcb", "cairo", "cairo-xcb"
@cimport {
  <xcb/xcb.h>
  <cairo/cairo.h>
  <cairo/cairo-xcb.h>
}

fn main()->i32 = unsafe {
  let conn = xcb_connect(null, null_mut)
  // ...
}
```

**Особенности**:
- Автоматический bindgen через libclang
- Кэширование FFI-AST
- Поддержка pkg-config
- Платформоспецифичные директивы
- C++ хедеры через @cppimport

### 7. Архитектура компилятора

**Пайплайн**:
```
Aurora.src → Aurora.CST → Aurora.AST → Aurora.CoreIR → Cpp.AST → C++ код
```

**Уровни представления**:
- **CST** (Concrete Syntax Tree) - для round-trip без потерь
- **AST** - синтаксис без шума
- **CoreIR** - общий знаменатель языка
- **C++ AST** - целевой кодоген

**Round-trip**:
- Aurora ↔ Aurora: полный round-trip через CST
- C++ ↔ C++: полный round-trip через CST
- Aurora ↔ C++: односторонний + импорт подмножества

### 8. Переходы между AST

**Aurora.AST → CoreIR**:
- Разворачивание сахара
- Нормализация match
- Канонические типы
- Маркировка эффектов

**CoreIR → Cpp.AST**:
- ADT → variant + визиторы
- match → visit/if constexpr
- slices → std::span
- Result → std::expected
- ownership → T/unique_ptr<T>/T&
- модули → C++20 modules/namespaces

## Ключевые выводы

1. **DSL подход** позволяет автоматизировать лучшие практики C++ и снизить количество ошибок
2. **Язык Aurora** - естественная эволюция DSL в полноценный язык
3. **Ограничения** - сознательное сужение возможностей C++ для повышения безопасности
4. **FFI** - ключевой механизм для работы с существующими библиотеками
5. **Архитектура** - многоуровневое представление с четкими переходами между AST
6. **Round-trip** - важная возможность для инструментов разработки

## Практические применения

- Инфраструктурные проекты
- API и SDK
- Системы сериализации
- Embedded разработка
- Игровые движки
- GPU вычисления
- Инструменты разработки
