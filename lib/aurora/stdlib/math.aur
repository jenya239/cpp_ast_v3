# Aurora Standard Library - Math Module
# Mathematical functions and utilities

module Math

# Basic arithmetic functions
fn abs(x: i32) -> i32 = 
  if x < 0 then -x else x

fn abs_f(x: f32) -> f32 = 
  if x < 0.0 then -x else x

fn min(a: i32, b: i32) -> i32 = 
  if a < b then a else b

fn max(a: i32, b: i32) -> i32 = 
  if a > b then a else b

fn min_f(a: f32, b: f32) -> f32 = 
  if a < b then a else b

fn max_f(a: f32, b: f32) -> f32 = 
  if a > b then a else b

# Power functions
fn pow(base: i32, exp: i32) -> i32 = 
  if exp <= 0 then 1
  else base * pow(base, exp - 1)

fn pow_f(base: f32, exp: f32) -> f32 = 
  # Simple implementation - in real stdlib would use more efficient algorithm
  if exp == 0.0 then 1.0
  else if exp > 0.0 then base * pow_f(base, exp - 1.0)
  else 1.0 / pow_f(base, -exp)

# Square root (simple implementation)
fn sqrt(x: f32) -> f32 = 
  if x < 0.0 then 0.0  # Error case
  else if x == 0.0 then 0.0
  else if x == 1.0 then 1.0
  else sqrt_approx(x, x / 2.0, 0.001)

fn sqrt_approx(x: f32, guess: f32, precision: f32) -> f32 = 
  let diff = guess * guess - x in
  if abs_f(diff) < precision then guess
  else sqrt_approx(x, (guess + x / guess) / 2.0, precision)

# Trigonometric functions (basic implementations)
fn sin(x: f32) -> f32 = 
  # Simple Taylor series approximation
  sin_approx(x, 0.0, 1.0, 1.0, 10)

fn sin_approx(x: f32, result: f32, term: f32, sign: f32, n: i32) -> f32 = 
  if n <= 0 then result
  else 
    let new_term = term * x * x / ((2 * n - 1) * (2 * n)) in
    sin_approx(x, result + sign * new_term, new_term, -sign, n - 1)

fn cos(x: f32) -> f32 = 
  # Simple Taylor series approximation
  cos_approx(x, 1.0, 1.0, -1.0, 10)

fn cos_approx(x: f32, result: f32, term: f32, sign: f32, n: i32) -> f32 = 
  if n <= 0 then result
  else 
    let new_term = term * x * x / ((2 * n) * (2 * n - 1)) in
    cos_approx(x, result + sign * new_term, new_term, -sign, n - 1)

# Constants
let PI: f32 = 3.14159265359
let E: f32 = 2.71828182846

end
