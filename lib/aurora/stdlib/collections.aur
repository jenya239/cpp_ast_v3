# Aurora Standard Library - Collections Module
# Collection utilities and algorithms

module Collections

# Array utilities
fn length<T>(arr: T[]) -> i32 = 
  arr.length()

fn is_empty<T>(arr: T[]) -> bool = 
  arr.length() == 0

fn first<T>(arr: T[]) -> T = 
  if arr.is_empty() then 
    # Error - should be handled differently in real implementation
    arr[0]  # This will cause runtime error
  else 
    arr[0]

fn last<T>(arr: T[]) -> T = 
  if arr.is_empty() then 
    # Error - should be handled differently in real implementation
    arr[0]  # This will cause runtime error
  else 
    arr[arr.length() - 1]

# Higher-order functions
fn map<T, U>(arr: T[], f: T -> U) -> U[] = 
  arr.map(f)

fn filter<T>(arr: T[], pred: T -> bool) -> T[] = 
  arr.filter(pred)

fn fold<T, U>(arr: T[], init: U, f: (U, T) -> U) -> U = 
  arr.fold(init, f)

fn reduce<T>(arr: T[], f: (T, T) -> T) -> T = 
  if arr.is_empty() then 
    # Error - should be handled differently in real implementation
    arr[0]  # This will cause runtime error
  else 
    let first = arr[0] in
    fold(arr[1..], first, f)

# Search functions
fn find<T>(arr: T[], pred: T -> bool) -> Option<T> = 
  find_helper(arr, pred, 0)

fn find_helper<T>(arr: T[], pred: T -> bool, index: i32) -> Option<T> = 
  if index >= arr.length() then None
  else if pred(arr[index]) then Some(arr[index])
  else find_helper(arr, pred, index + 1)

fn contains<T>(arr: T[], item: T) -> bool = 
  contains_helper(arr, item, 0)

fn contains_helper<T>(arr: T[], item: T, index: i32) -> bool = 
  if index >= arr.length() then false
  else if arr[index] == item then true
  else contains_helper(arr, item, index + 1)

# Option type for safe operations
type Option<T> = Some(T) | None

# Sorting (simple bubble sort)
fn sort<T>(arr: T[], compare: (T, T) -> i32) -> T[] = 
  sort_helper(arr, 0, arr.length() - 1, compare)

fn sort_helper<T>(arr: T[], start: i32, end: i32, compare: (T, T) -> i32) -> T[] = 
  if start >= end then arr
  else 
    let swapped = bubble_pass(arr, start, end, compare) in
    if swapped then sort_helper(arr, start, end - 1, compare)
    else arr

fn bubble_pass<T>(arr: T[], start: i32, end: i32, compare: (T, T) -> i32) -> bool = 
  if start >= end then false
  else 
    let swapped = if compare(arr[start], arr[start + 1]) > 0 then 
      # Swap elements - this is simplified, real implementation would need mutable arrays
      true
    else false in
    bubble_pass(arr, start + 1, end, compare) || swapped

end
