# Aurora Standard Library - Prelude
# Main entry point for the standard library

# Re-export all standard library modules
import Math
import Collections  
import String
import IO
import Option

# Common type aliases
type Int = i32
type Float = f32
type Double = f64
type Bool = bool
type String = str

# Common constants
let MAX_INT: i32 = 2147483647
let MIN_INT: i32 = -2147483648
let MAX_FLOAT: f32 = 3.4028235e38
let MIN_FLOAT: f32 = -3.4028235e38

# Common utility functions
fn identity<T>(x: T) -> T = x

fn const<T, U>(x: T) -> U -> T = 
  _ => x

fn flip<T, U, V>(f: T -> U -> V) -> U -> T -> V = 
  (u, t) => f(t)(u)

fn compose<T, U, V>(f: U -> V, g: T -> U) -> T -> V = 
  x => f(g(x))

fn pipe<T, U, V>(x: T, f: T -> U, g: U -> V) -> V = 
  g(f(x))

# Type checking utilities
fn is_numeric<T>(x: T) -> bool = 
  # This would need type system support
  true

fn is_string<T>(x: T) -> bool = 
  # This would need type system support
  true

# Debug utilities
fn dbg<T>(x: T) -> T = 
  IO.debug_print("dbg: " + to_string(x));
  x

fn dbg_with<T>(x: T, message: str) -> T = 
  IO.debug_print(message + ": " + to_string(x));
  x

# Assertion utilities
fn assert(condition: bool, message: str) -> void = 
  if !condition then IO.panic("Assertion failed: " + message)

fn assert_eq<T>(left: T, right: T, message: str) -> void = 
  if left != right then 
    IO.panic("Assertion failed: " + message + " (left: " + to_string(left) + ", right: " + to_string(right) + ")")

fn assert_ne<T>(left: T, right: T, message: str) -> void = 
  if left == right then 
    IO.panic("Assertion failed: " + message + " (values are equal: " + to_string(left) + ")")

# Range utilities
fn range(start: i32, end: i32) -> i32[] = 
  range_helper(start, end, [])

fn range_helper(start: i32, end: i32, acc: i32[]) -> i32[] = 
  if start >= end then acc
  else range_helper(start + 1, end, acc.push(start))

fn range_step(start: i32, end: i32, step: i32) -> i32[] = 
  range_step_helper(start, end, step, [])

fn range_step_helper(start: i32, end: i32, step: i32, acc: i32[]) -> i32[] = 
  if start >= end then acc
  else range_step_helper(start + step, end, step, acc.push(start))

# List comprehensions utilities
fn replicate<T>(n: i32, x: T) -> T[] = 
  if n <= 0 then []
  else [x] + replicate(n - 1, x)

fn take<T>(n: i32, list: T[]) -> T[] = 
  if n <= 0 then []
  else if list.is_empty() then []
  else [list[0]] + take(n - 1, list[1..])

fn drop<T>(n: i32, list: T[]) -> T[] = 
  if n <= 0 then list
  else if list.is_empty() then []
  else drop(n - 1, list[1..])

# String utilities
fn show<T>(x: T) -> str = 
  to_string(x)

fn print_ln<T>(x: T) -> void = 
  IO.println(show(x))

fn print_space<T>(x: T) -> void = 
  IO.print(show(x) + " ")

fn print_tab<T>(x: T) -> void = 
  IO.print(show(x) + "\t")
